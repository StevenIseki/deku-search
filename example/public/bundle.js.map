{"version":3,"sources":["webpack:///webpack/bootstrap 2998d642b0a07d47aa0f","webpack:///./example.js","webpack:///../lib/search.js","webpack:///../~/deku/lib/index.js","webpack:///../~/deku/lib/application.js","webpack:///../~/component-emitter/index.js","webpack:///../~/deku/lib/render.js","webpack:///../~/component-raf/index.js","webpack:///../~/is-dom/index.js","webpack:///../~/get-uid/index.js","webpack:///../~/object-path/index.js","webpack:///../~/deku/lib/events.js","webpack:///../~/deku/lib/svg.js","webpack:///../~/is-svg-element/index.js","webpack:///../~/is-svg-attribute/index.js","webpack:///../~/object-defaults/index.js","webpack:///../~/fast.js/forEach.js","webpack:///../~/fast.js/array/forEach.js","webpack:///../~/fast.js/function/bindInternal3.js","webpack:///../~/fast.js/object/forEach.js","webpack:///../~/fast.js/object/assign.js","webpack:///../~/fast.js/reduce.js","webpack:///../~/fast.js/array/reduce.js","webpack:///../~/fast.js/function/bindInternal4.js","webpack:///../~/fast.js/object/reduce.js","webpack:///../~/deku/lib/node-type.js","webpack:///../~/component-type/index.js","webpack:///../~/buffer/index.js","webpack:///../~/base64-js/lib/b64.js","webpack:///../~/ieee754/index.js","webpack:///../~/isarray/index.js","webpack:///../~/deku/lib/stringify.js","webpack:///../~/virtual-element/index.js","webpack:///../~/sliced/index.js","webpack:///../~/sliced/lib/sliced.js","webpack:///../~/array-flatten/array-flatten.js","webpack:///../lib/SearchItemInArray.js","webpack:///./Counter.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AClCA,UAAS,MAAM,CAAE,CAAC,EAAE;AAClB,UAAO,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC;AAC3B,UAAO,CAAC,GAAG,CAAC,iCAAiC,CAAC;EAC/C;;AAMD,KAAI,OAAO,GAAG,UAFC,IAAI,EAGjB;;KAAK,SAAM,KAAK;GACd,mDAAS,KAAK,EAAC,MAAM,GAAG;GACxB,mDAAS,KAAK,EAAC,SAAS,GAAG;GAC3B,qDAAU;EACN,CACP,CAAC;;AAEF,WAVQ,MAAM,EAUP,OAAO,EAAE,QAAQ,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;;;;;;;;;;;;;ACrBhD,aAAY,CAAC;;AAEb,OAAM,CAAC,cAAc,CAAC,OAAO,EAAE,YAAY,EAAE;AAC3C,QAAK,EAAE,IAAI;EACZ,CAAC,CAAC;;AAEH,KAAI,KAAK,GAAG,mBAAO,CAAC,CAAM,CAAC,CAAC;;AAE5B,KAAI,eAAe,GAAG,mBAAO,CAAC,EAAiB,CAAC,CAAC;;AAEjD,KAAI,gBAAgB,GAAG,sBAAsB,CAAC,eAAe,CAAC,CAAC;;AAE/D,KAAI,kBAAkB,GAAG,mBAAO,CAAC,EAAqB,CAAC,CAAC;;AAExD,KAAI,mBAAmB,GAAG,sBAAsB,CAAC,kBAAkB,CAAC,CAAC;;AAErE,UAAS,sBAAsB,CAAC,GAAG,EAAE;AAAE,UAAO,GAAG,IAAI,GAAG,CAAC,UAAU,GAAG,GAAG,GAAG,EAAE,OAAO,EAAE,GAAG,EAAE,CAAC;EAAE;;AAE/F,KAAI,MAAM,GAAG;AACX,eAAY,EAAE,SAAS,YAAY,GAAG;AACpC,YAAO,EAAE,aAAa,EAAE,EAAE,EAAE,CAAC;IAC9B;AACD,SAAM,EAAE,SAAS,MAAM,CAAC,SAAS,EAAE;AACjC,SAAI,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC;AAC5B,SAAI,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC;AAC5B,SAAI,aAAa,GAAG,KAAK,CAAC,aAAa,CAAC;;AAExC,SAAI,KAAK,GAAG,KAAK,CAAC,aAAa,CAAC,GAAG,CAAC,UAAU,IAAI,EAAE,CAAC,EAAE;AACrD,cAAO,CAAC,CAAC,EAAE,gBAAgB,CAAC,OAAO,EACjC,IAAI,EACJ,EAAE,GAAG,EAAE,CAAC,EAAE,OAAO,EAAE,WAAW,EAAE,EAChC,CAAC,CAAC,EAAE,gBAAgB,CAAC,OAAO,EAC1B,GAAG,EACH,EAAE,OAAO,EAAE,kBAAkB,EAAE,EAC/B,IAAI,CACL,CACF,CAAC;MACH,CAAC,CAAC;;AAEH,YAAO,CAAC,CAAC,EAAE,gBAAgB,CAAC,OAAO,EACjC,KAAK,EACL,EAAE,OAAO,EAAE,aAAa,EAAE,EAC1B,CAAC,CAAC,EAAE,gBAAgB,CAAC,OAAO,EAAE,OAAO,EAAE;AACrC,WAAI,EAAE,MAAM;AACZ,cAAO,EAAE,OAAO;AAChB,kBAAW,EAAE,KAAK,CAAC,WAAW;AAC9B,UAAG,EAAE,aAAa;AAClB,cAAO,EAAE,WAAW,EAAE,CAAC,EACzB,CAAC,CAAC,EAAE,gBAAgB,CAAC,OAAO,EAC1B,KAAK,EACL,EAAE,OAAO,EAAE,MAAM,EAAE,GAAG,EAAE,cAAc,EAAE,EACxC,CAAC,CAAC,EAAE,gBAAgB,CAAC,OAAO,EAC1B,IAAI,EACJ,EAAE,OAAO,EAAE,YAAY,EAAE,EACzB,KAAK,CACN,CACF,CACF,CAAC;IACH;AACD,cAAW,EAAE,SAAS,WAAW,CAAC,SAAS,EAAE;AAC3C,SAAI,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC;AAC5B,SAAI,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC;IAC7B;AACD,aAAU,EAAE,SAAS,UAAU,CAAC,SAAS,EAAE,EAAE,EAAE,QAAQ,EAAE;AACvD,SAAI,OAAO,GAAG,CAAC,CAAC;AAChB,cAAS,CAAC,QAAQ,GAAG,WAAW,CAAC,YAAY;AAC3C,eAAQ,CAAC,EAAE,cAAc,EAAE,OAAO,EAAE,EAAE,CAAC,CAAC;MACzC,EAAE,IAAI,CAAC,CAAC;IACV;AACD,gBAAa,EAAE,SAAS,aAAa,CAAC,SAAS,EAAE;AAC/C,kBAAa,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;IACnC;EACF;;AAED,QAAO,CAAC,OAAO,GAAG,MAAM,CAAC;;AAEzB,UAAS,WAAW,CAAC,CAAC,EAAE;AACtB,OAAI,OAAO,KAAK,CAAC,QAAQ,KAAK,WAAW,EAAE;AACzC,UAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;IACnB;AACD,OAAI,WAAW,GAAG,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC;AAC9C,OAAI,MAAM,GAAG,CAAC,CAAC,EAAE,mBAAmB,CAAC,OAAO,EAAE,KAAK,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC;AACxE,OAAI,CAAC,QAAQ,CAAC,EAAE,aAAa,EAAE,MAAM,EAAE,CAAC,CAAC;EAC1C;;AAED,UAAS,kBAAkB,CAAC,CAAC,EAAE;AAC7B,OAAI,OAAO,KAAK,CAAC,OAAO,KAAK,WAAW,EAAE;AACxC,UAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;IAClB;;AAED,OAAI,MAAM,GAAG,CAAC,CAAC,MAAM,CAAC,SAAS,CAAC;AAChC,OAAI,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,GAAG,MAAM,CAAC;;;;;;;AC3FvC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+C;;;;;;ACpBA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAW,SAAS;AACpB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,eAAe;AAC1B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnFA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,MAAM;AACjB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA2C,SAAS;AACpD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;;;;;;;AChKA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAW,YAAY;AACvB,YAAW,YAAY;AACvB,YAAW,OAAO;AAClB;AACA,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mCAAkC,mBAAmB,YAAY;AACjE;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,eAAe;AAC5B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,EAAE;AACf;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA,eAAc,SAAS;AACvB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gDAA+C,2BAA2B;AAC1E;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2DAA0D;AAC1D,4DAA2D;AAC3D,oCAAmC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP,MAAK;AACL;;AAEA;AACA,sBAAqB,eAAe;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA,6CAA4C,0BAA0B;AACtE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,YAAY;AACzB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,YAAY;AACzB,cAAa,OAAO;AACpB;AACA,eAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,YAAY;AACzB;AACA,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,YAAY;AACzB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,YAAY;AACzB,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA,eAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,YAAY;AACzB;AACA,eAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,YAAY;AACzB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,MAAM;AACnB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA,eAAc;AACd;;AAEA;AACA;AACA,sCAAqC,gDAAgD;AACrF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC;AACnC,oCAAmC;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,UAAU;AACvB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,cAAa,MAAM;AACnB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,UAAU;AACrB,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,8BAA8B;AACzE;AACA,gCAA+B;AAC/B,gCAA+B;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,YAAY;AACxB,aAAY,YAAY;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,YAAY;AACvB,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,YAAY;AACvB;AACA,aAAY;AACZ;;AAEA;AACA;AACA;;;;;;;ACzxCA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACjCA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;ACdA;AACA;;AAEA;AACA;AACA,G;;;;;;ACLA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,EAAC;AACD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK,IAAI;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA,oBAAmB,iBAAiB;AACpC;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,wCAAuC,SAAS;AAChD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAC;;;;;;;ACrRD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3CA;AACA;AACA;AACA;AACA;;;;;;;ACJA;AACA;AACA;AACA,WAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;;;;;;;ACnCA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;;;;;;;AC1DA;;AAEA;AACA;;AAEA,kBAAiB,sBAAsB;AACvC;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;;;;;;AChBA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAY,aAAa;AACzB,aAAY,SAAS;AACrB,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G;;;;;;ACrBA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAY,MAAM;AAClB,aAAY,SAAS;AACrB,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,cAAa,YAAY;AACzB;AACA;AACA;;;;;;;ACpBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACVA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,SAAS;AACrB,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,YAAY;AACzB;AACA;AACA;AACA;;;;;;;ACtBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA,cAAa,eAAe;AAC5B;AACA;AACA;AACA,gBAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjCA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAY,aAAa;AACzB,aAAY,SAAS;AACrB,aAAY,MAAM;AAClB,aAAY,OAAO;AACnB,aAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G;;;;;;ACvBA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAY,MAAM;AAClB,aAAY,SAAS;AACrB,aAAY,MAAM;AAClB,aAAY,OAAO;AACnB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAQ,YAAY;AACpB;AACA;;AAEA;AACA;;;;;;;AClCA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACVA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,SAAS;AACrB,aAAY,MAAM;AAClB,aAAY,OAAO;AACnB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAQ,YAAY;AACpB;AACA;AACA;;AAEA;AACA;;;;;;;ACpCA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACfA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA,iBAAgB,oCAAoC;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;AACA,cAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iDAAgD,EAAE;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,6BAA6B;AAChD;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,oBAAmB,cAAc;AACjC;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wDAAuD,OAAO;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,wDAAuD,OAAO;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAqB,QAAQ;AAC7B;AACA;AACA,IAAG;AACH;AACA,gBAAe,SAAS;AACxB;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAkB;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA,IAAG;AACH;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,wCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB,YAAY;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,gBAAgB;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;;;;;;;AC3gDA;;AAEA,EAAC;AACD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,qBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kDAAiD,YAAY;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAC,6BAAqD;;;;;;;AC3HtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAQ,WAAW;;AAEnB;AACA;AACA;AACA,SAAQ,WAAW;;AAEnB;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA,SAAQ,WAAW;;AAEnB;AACA;AACA,SAAQ,UAAU;;AAElB;AACA;;;;;;;ACnFA,kBAAiB;;AAEjB;AACA;AACA;;;;;;;ACJA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,UAAU;AACvB,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA,wCAAuC,8BAA8B;AACrE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uDAAsD,6BAA6B;AACnF,yDAAwD,6BAA6B;AACrF,kCAAiC,6BAA6B;AAC9D;AACA;;AAEA;AACA;AACA;AACA,cAAa,KAAK;AAClB,cAAa,KAAK;AAClB;AACA,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT,+CAA8C,OAAO;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,IAAI;AACf;AACA,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACnIA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA8B,YAAY;AAC1C,oBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,YAAW,OAAO;AAClB,YAAW,MAAM;AACjB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,4CAA2C,kCAAkC;;AAE7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvEA;;;;;;;;ACCA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;AC/BA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,MAAM;AAClB,aAAY,MAAM;AAClB,aAAY,OAAO;AACnB,aAAY;AACZ;AACA;AACA,kBAAiB,kBAAkB;AACnC;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAY,MAAM;AAClB,aAAY,MAAM;AAClB,aAAY;AACZ;AACA;AACA,kBAAiB,kBAAkB;AACnC;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAY,MAAM;AAClB,aAAY,OAAO;AACnB,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;AC/DA,aAAY,CAAC;;AAEb,KAAI,iBAAiB,GAAG,SAAS,iBAAiB,CAAC,KAAK,EAAE,KAAK,EAAE;AAC/D,OAAI,KAAK,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE;AACvB,YAAO,EAAE,CAAC;IACX;AACD,OAAI,GAAG,GAAG,IAAI,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC;;AAE1E,UAAO,KAAK,CAAC,MAAM,CAAC,UAAU,IAAI,EAAE;AAClC,SAAI,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;AAClB,cAAO,IAAI,CAAC;MACb;IACF,CAAC,CAAC;EACJ,CAAC;;AAEF,OAAM,CAAC,OAAO,GAAG,iBAAiB,C;;;;;;;;;;;;;;;;;;;;;;ACVlC,KAAI,OAAO,GAAG;AAEZ,eAAY,0BAAI;AACd,YAAO,EAAE,cAAc,EAAE,CAAC,EAAE;IAC7B;AAED,SAAM,kBAAE,SAAS,EAAE;SACX,KAAK,GAAY,SAAS,CAA1B,KAAK;SAAE,KAAK,GAAK,SAAS,CAAnB,KAAK;SACZ,cAAc,GAAK,KAAK,CAAxB,cAAc;;AAEpB,YACE;;SAAK,SAAM,SAAS;OAClB;;WAAI,uBAAmB,KAAK,CAAC,KAAQ;;SACxB,cAAc;QACtB;MACD,CACN;IACH;AAED,cAAW,uBAAE,SAAS,EAAE;SAChB,KAAK,GAAY,SAAS,CAA1B,KAAK;SAAE,KAAK,GAAK,SAAS,CAAnB,KAAK;IACnB;AAED,aAAU,sBAAE,SAAS,EAAE,EAAE,EAAE,QAAQ,EAAE;AACnC,SAAI,OAAO,GAAG,CAAC,CAAC;AAChB,cAAS,CAAC,QAAQ,GAAG,WAAW,CAAC,YAAM;AACpC,eAAQ,CAAC,EAAE,cAAc,EAAE,OAAO,EAAE,EAAE,CAAC;MACzC,EAAE,IAAI,CAAC,CAAC;IACV;AAED,gBAAa,yBAAE,SAAS,EAAE;AACxB,kBAAa,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;IACnC;EACF;;mBAEc,OAAO,C","file":"./example/public/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"public\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 2998d642b0a07d47aa0f\n **/","/** @jsx element */\n\nimport Search from '../lib/search'\n\nfunction myFunc (e) {\n  console.log(e.target.value)\n  console.log('love coming in to this callback')\n}\n\nimport element from 'virtual-element'\nimport Counter from './Counter';\nimport {render,tree} from 'deku'\n\nlet counter = tree(\n  <div class='app'>\n    <Counter color='pink' />\n    <Counter color='darkred' />\n    <Search />\n  </div>\n);\n\nrender(counter, document.getElementById('root'))\n\n/*\n<Search items={this.props.items}\n        placeHolder='Search for a programming language'\n        onChange={this.myFunc} />\n*/\n//let ITEMS = ['ruby', 'javascript', 'lua', 'go', 'c++', 'julia', 'java', 'c', 'scala', 'haskell']\n\n\n\n/** WEBPACK FOOTER **\n ** ./example.js\n **/","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _deku = require('deku');\n\nvar _virtualElement = require('virtual-element');\n\nvar _virtualElement2 = _interopRequireDefault(_virtualElement);\n\nvar _SearchItemInArray = require('./SearchItemInArray');\n\nvar _SearchItemInArray2 = _interopRequireDefault(_SearchItemInArray);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Search = {\n  initialState: function initialState() {\n    return { matchingItems: [] };\n  },\n  render: function render(component) {\n    var props = component.props;\n    var state = component.state;\n    var matchingItems = state.matchingItems;\n\n    var items = state.matchingItems.map(function (item, i) {\n      return (0, _virtualElement2.default)(\n        'li',\n        { key: i, 'class': 'menu-item' },\n        (0, _virtualElement2.default)(\n          'a',\n          { onClick: selectAutoComplete },\n          item\n        )\n      );\n    });\n\n    return (0, _virtualElement2.default)(\n      'div',\n      { 'class': 'deku-search' },\n      (0, _virtualElement2.default)('input', {\n        type: 'text',\n        'class': 'input',\n        placeholder: props.placeHolder,\n        ref: 'searchInput',\n        onKeyUp: changeInput }),\n      (0, _virtualElement2.default)(\n        'div',\n        { 'class': 'menu', ref: 'autocomplete' },\n        (0, _virtualElement2.default)(\n          'ul',\n          { 'class': 'menu-items' },\n          items\n        )\n      )\n    );\n  },\n  afterUpdate: function afterUpdate(component) {\n    var props = component.props;\n    var state = component.state;\n  },\n  afterMount: function afterMount(component, el, setState) {\n    var counter = 0;\n    component.interval = setInterval(function () {\n      setState({ secondsElapsed: counter++ });\n    }, 1000);\n  },\n  beforeUnmount: function beforeUnmount(component) {\n    clearInterval(component.interval);\n  }\n}; /** @jsx element */\n\nexports.default = Search;\n\nfunction changeInput(e) {\n  if (typeof props.onChange !== 'undefined') {\n    props.onChange(e);\n  }\n  var searchValue = this.refs.searchInput.value;\n  var result = (0, _SearchItemInArray2.default)(props.items, searchValue);\n  this.setState({ matchingItems: result });\n}\n\nfunction selectAutoComplete(e) {\n  if (typeof props.onClick !== 'undefined') {\n    props.onClick(e);\n  }\n\n  var result = e.target.innerHTML;\n  this.refs.searchInput.value = result;\n}\n\n\n/** WEBPACK FOOTER **\n ** ../lib/search.js\n **/","/**\n * Create the application.\n */\n\nexports.tree =\nexports.scene =\nexports.deku = require('./application')\n\n/**\n * Render scenes to the DOM.\n */\n\nif (typeof document !== 'undefined') {\n  exports.render = require('./render')\n}\n\n/**\n * Render scenes to a string\n */\n\nexports.renderString = require('./stringify')\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/deku/lib/index.js\n ** module id = 2\n ** module chunks = 0\n **/","/**\n * Module dependencies.\n */\n\nvar Emitter = require('component-emitter')\n\n/**\n * Expose `scene`.\n */\n\nmodule.exports = Application\n\n/**\n * Create a new `Application`.\n *\n * @param {Object} element Optional initial element\n */\n\nfunction Application (element) {\n  if (!(this instanceof Application)) return new Application(element)\n  this.options = {}\n  this.sources = {}\n  this.element = element\n}\n\n/**\n * Mixin `Emitter`.\n */\n\nEmitter(Application.prototype)\n\n/**\n * Add a plugin\n *\n * @param {Function} plugin\n */\n\nApplication.prototype.use = function (plugin) {\n  plugin(this)\n  return this\n}\n\n/**\n * Set an option\n *\n * @param {String} name\n */\n\nApplication.prototype.option = function (name, val) {\n  this.options[name] = val\n  return this\n}\n\n/**\n * Set value used somewhere in the IO network.\n */\n\nApplication.prototype.set = function (name, data) {\n  this.sources[name] = data\n  this.emit('source', name, data)\n  return this\n}\n\n/**\n * Mount a virtual element.\n *\n * @param {VirtualElement} element\n */\n\nApplication.prototype.mount = function (element) {\n  this.element = element\n  this.emit('mount', element)\n  return this\n}\n\n/**\n * Remove the world. Unmount everything.\n */\n\nApplication.prototype.unmount = function () {\n  if (!this.element) return\n  this.element = null\n  this.emit('unmount')\n  return this\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/deku/lib/application.js\n ** module id = 3\n ** module chunks = 0\n **/","\n/**\n * Expose `Emitter`.\n */\n\nmodule.exports = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  function on() {\n    this.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks['$' + event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks['$' + event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n  var args = [].slice.call(arguments, 1)\n    , callbacks = this._callbacks['$' + event];\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks['$' + event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/component-emitter/index.js\n ** module id = 4\n ** module chunks = 0\n **/","/**\n * Dependencies.\n */\n\nvar raf = require('component-raf')\nvar isDom = require('is-dom')\nvar uid = require('get-uid')\nvar keypath = require('object-path')\nvar events = require('./events')\nvar svg = require('./svg')\nvar defaults = require('object-defaults')\nvar forEach = require('fast.js/forEach')\nvar assign = require('fast.js/object/assign')\nvar reduce = require('fast.js/reduce')\nvar nodeType = require('./node-type')\n\n/**\n * Expose `dom`.\n */\n\nmodule.exports = render\n\n/**\n * Render an app to the DOM\n *\n * @param {Application} app\n * @param {HTMLElement} container\n * @param {Object} opts\n *\n * @return {Object}\n */\n\nfunction render (app, container, opts) {\n  var frameId\n  var isRendering\n  var rootId = 'root'\n  var currentElement\n  var currentNativeElement\n  var connections = {}\n  var components = {}\n  var entities = {}\n  var handlers = {}\n  var mountQueue = []\n  var children = {}\n  children[rootId] = {}\n\n  if (!isDom(container)) {\n    throw new Error('Container element must be a DOM element')\n  }\n\n  /**\n   * Rendering options. Batching is only ever really disabled\n   * when running tests, and pooling can be disabled if the user\n   * is doing something stupid with the DOM in their components.\n   */\n\n  var options = defaults(assign({}, app.options || {}, opts || {}), {\n    batching: true\n  })\n\n  /**\n   * Listen to DOM events\n   */\n  var rootElement = getRootElement(container)\n  addNativeEventListeners()\n\n  /**\n   * Watch for changes to the app so that we can update\n   * the DOM as needed.\n   */\n\n  app.on('unmount', onunmount)\n  app.on('mount', onmount)\n  app.on('source', onupdate)\n\n  /**\n   * If the app has already mounted an element, we can just\n   * render that straight away.\n   */\n\n  if (app.element) render()\n\n  /**\n   * Teardown the DOM rendering so that it stops\n   * rendering and everything can be garbage collected.\n   */\n\n  function teardown () {\n    removeNativeEventListeners()\n    removeNativeElement()\n    app.off('unmount', onunmount)\n    app.off('mount', onmount)\n    app.off('source', onupdate)\n  }\n\n  /**\n   * Swap the current rendered node with a new one that is rendered\n   * from the new virtual element mounted on the app.\n   *\n   * @param {VirtualElement} element\n   */\n\n  function onmount () {\n    invalidate()\n  }\n\n  /**\n   * If the app unmounts an element, we should clear out the current\n   * rendered element. This will remove all the entities.\n   */\n\n  function onunmount () {\n    removeNativeElement()\n    currentElement = null\n  }\n\n  /**\n   * Update all components that are bound to the source\n   *\n   * @param {String} name\n   * @param {*} data\n   */\n\n  function onupdate (name, data) {\n    if (!connections[name]) return;\n    connections[name].forEach(function(update) {\n      update(data)\n    })\n  }\n\n  /**\n   * Render and mount a component to the native dom.\n   *\n   * @param {Entity} entity\n   * @return {HTMLElement}\n   */\n\n  function mountEntity (entity) {\n    register(entity)\n    setSources(entity)\n    children[entity.id] = {}\n    entities[entity.id] = entity\n\n    // commit initial state and props.\n    commit(entity)\n\n    // callback before mounting.\n    trigger('beforeMount', entity, [entity.context])\n    trigger('beforeRender', entity, [entity.context])\n\n    // render virtual element.\n    var virtualElement = renderEntity(entity)\n    // create native element.\n    var nativeElement = toNative(entity.id, '0', virtualElement)\n\n    entity.virtualElement = virtualElement\n    entity.nativeElement = nativeElement\n\n    // Fire afterRender and afterMount hooks at the end\n    // of the render cycle\n    mountQueue.push(entity.id)\n\n    return nativeElement\n  }\n\n  /**\n   * Remove a component from the native dom.\n   *\n   * @param {Entity} entity\n   */\n\n  function unmountEntity (entityId) {\n    var entity = entities[entityId]\n    if (!entity) return\n    trigger('beforeUnmount', entity, [entity.context, entity.nativeElement])\n    unmountChildren(entityId)\n    removeAllEvents(entityId)\n    var componentEntities = components[entityId].entities;\n    delete componentEntities[entityId]\n    delete components[entityId]\n    delete entities[entityId]\n    delete children[entityId]\n  }\n\n  /**\n   * Render the entity and make sure it returns a node\n   *\n   * @param {Entity} entity\n   *\n   * @return {VirtualTree}\n   */\n\n  function renderEntity (entity) {\n    var component = entity.component\n    var fn = typeof component === 'function' ? component : component.render\n    if (!fn) throw new Error('Component needs a render function')\n    var result = fn(entity.context, setState(entity))\n    if (!result) throw new Error('Render function must return an element.')\n    return result\n  }\n\n  /**\n   * Whenever setState or setProps is called, we mark the entity\n   * as dirty in the renderer. This lets us optimize the re-rendering\n   * and skip components that definitely haven't changed.\n   *\n   * @param {Entity} entity\n   *\n   * @return {Function} A curried function for updating the state of an entity\n   */\n\n  function setState (entity) {\n    return function (nextState) {\n      updateEntityState(entity, nextState)\n    }\n  }\n\n  /**\n   * Tell the app it's dirty and needs to re-render. If batching is disabled\n   * we can just trigger a render immediately, otherwise we'll wait until\n   * the next available frame.\n   */\n\n  function invalidate () {\n    if (!options.batching) {\n      if (!isRendering) render()\n    } else {\n      if (!frameId) frameId = raf(render)\n    }\n  }\n\n  /**\n   * Update the DOM. If the update fails we stop the loop\n   * so we don't get errors on every frame.\n   *\n   * @api public\n   */\n\n  function render () {\n    // If this is called synchronously we need to\n    // cancel any pending future updates\n    clearFrame()\n\n    // If the rendering from the previous frame is still going,\n    // we'll just wait until the next frame. Ideally renders should\n    // not take over 16ms to stay within a single frame, but this should\n    // catch it if it does.\n    if (isRendering) {\n      frameId = raf(render)\n      return\n    } else {\n      isRendering = true\n    }\n\n    // 1. If there isn't a native element rendered for the current mounted element\n    // then we need to create it from scratch.\n    // 2. If a new element has been mounted, we should diff them.\n    // 3. We should update check all child components for changes.\n    if (!currentNativeElement) {\n      currentElement = app.element\n      currentNativeElement = toNative(rootId, '0', currentElement)\n      if (container.children.length > 0) {\n        console.info('deku: The container element is not empty. These elements will be removed. Read more: http://cl.ly/b0Sr')\n      }\n      if (container === document.body) {\n        console.warn('deku: Using document.body is allowed but it can cause some issues. Read more: http://cl.ly/b0SC')\n      }\n      removeAllChildren(container)\n      container.appendChild(currentNativeElement)\n    } else if (currentElement !== app.element) {\n      currentNativeElement = patch(rootId, currentElement, app.element, currentNativeElement)\n      currentElement = app.element\n      updateChildren(rootId)\n    } else {\n      updateChildren(rootId)\n    }\n\n    // Call mount events on all new entities\n    flushMountQueue()\n\n    // Allow rendering again.\n    isRendering = false\n\n  }\n\n  /**\n   * Call hooks for all new entities that have been created in\n   * the last render from the bottom up.\n   */\n\n  function flushMountQueue () {\n    while (mountQueue.length > 0) {\n      var entityId = mountQueue.shift()\n      var entity = entities[entityId]\n      trigger('afterRender', entity, [entity.context, entity.nativeElement])\n      trigger('afterMount', entity, [entity.context, entity.nativeElement, setState(entity)])\n    }\n  }\n\n  /**\n   * Clear the current scheduled frame\n   */\n\n  function clearFrame () {\n    if (!frameId) return\n    raf.cancel(frameId)\n    frameId = 0\n  }\n\n  /**\n   * Update a component.\n   *\n   * The entity is just the data object for a component instance.\n   *\n   * @param {String} id Component instance id.\n   */\n\n  function updateEntity (entityId) {\n    var entity = entities[entityId]\n    setSources(entity)\n\n    if (!shouldUpdate(entity)) {\n      commit(entity)\n      return updateChildren(entityId)\n    }\n\n    var currentTree = entity.virtualElement\n    var nextProps = entity.pendingProps\n    var nextState = entity.pendingState\n    var previousState = entity.context.state\n    var previousProps = entity.context.props\n\n    // hook before rendering. could modify state just before the render occurs.\n    trigger('beforeUpdate', entity, [entity.context, nextProps, nextState])\n    trigger('beforeRender', entity, [entity.context])\n\n    // commit state and props.\n    commit(entity)\n\n    // re-render.\n    var nextTree = renderEntity(entity)\n\n    // if the tree is the same we can just skip this component\n    // but we should still check the children to see if they're dirty.\n    // This allows us to memoize the render function of components.\n    if (nextTree === currentTree) return updateChildren(entityId)\n\n    // apply new virtual tree to native dom.\n    entity.nativeElement = patch(entityId, currentTree, nextTree, entity.nativeElement)\n    entity.virtualElement = nextTree\n    updateChildren(entityId)\n\n    // trigger render hook\n    trigger('afterRender', entity, [entity.context, entity.nativeElement])\n\n    // trigger afterUpdate after all children have updated.\n    trigger('afterUpdate', entity, [entity.context, previousProps, previousState, setState(entity)])\n  }\n\n  /**\n   * Update all the children of an entity.\n   *\n   * @param {String} id Component instance id.\n   */\n\n  function updateChildren (entityId) {\n    forEach(children[entityId], function (childId) {\n      updateEntity(childId)\n    })\n  }\n\n  /**\n   * Remove all of the child entities of an entity\n   *\n   * @param {Entity} entity\n   */\n\n  function unmountChildren (entityId) {\n    forEach(children[entityId], function (childId) {\n      unmountEntity(childId)\n    })\n  }\n\n  /**\n   * Remove the root element. If this is called synchronously we need to\n   * cancel any pending future updates.\n   */\n\n  function removeNativeElement () {\n    clearFrame()\n    removeElement(rootId, '0', currentNativeElement)\n    currentNativeElement = null\n  }\n\n  /**\n   * Create a native element from a virtual element.\n   *\n   * @param {String} entityId\n   * @param {String} path\n   * @param {Object} vnode\n   *\n   * @return {HTMLDocumentFragment}\n   */\n\n  function toNative (entityId, path, vnode) {\n    switch (nodeType(vnode)) {\n      case 'text': return toNativeText(vnode)\n      case 'empty': return toNativeEmptyElement(entityId, path)\n      case 'element': return toNativeElement(entityId, path, vnode)\n      case 'component': return toNativeComponent(entityId, path, vnode)\n    }\n  }\n\n  /**\n   * Create a native text element from a virtual element.\n   *\n   * @param {Object} vnode\n   */\n\n  function toNativeText (text) {\n    return document.createTextNode(text)\n  }\n\n  /**\n   * Create a native element from a virtual element.\n   */\n\n  function toNativeElement (entityId, path, vnode) {\n    var el\n    var attributes = vnode.attributes\n    var tagName = vnode.type\n    var childNodes = vnode.children\n\n    // create element either from pool or fresh.\n    if (svg.isElement(tagName)) {\n      el = document.createElementNS(svg.namespace, tagName)\n    } else {\n      el = document.createElement(tagName)\n    }\n\n    // set attributes.\n    forEach(attributes, function (value, name) {\n      setAttribute(entityId, path, el, name, value)\n    })\n\n    // add children.\n    forEach(childNodes, function (child, i) {\n      var childEl = toNative(entityId, path + '.' + i, child)\n      if (!childEl.parentNode) el.appendChild(childEl)\n    })\n\n    // store keys on the native element for fast event handling.\n    el.__entity__ = entityId\n    el.__path__ = path\n\n    return el\n  }\n\n  /**\n   * Create a native element from a virtual element.\n   */\n\n  function toNativeEmptyElement (entityId, path) {\n    var el = document.createElement('noscript')\n    el.__entity__ = entityId\n    el.__path__ = path\n    return el\n  }\n\n  /**\n   * Create a native element from a component.\n   */\n\n  function toNativeComponent (entityId, path, vnode) {\n    var child = new Entity(vnode.type, assign({ children: vnode.children }, vnode.attributes), entityId)\n    children[entityId][path] = child.id\n    return mountEntity(child)\n  }\n\n  /**\n   * Patch an element with the diff from two trees.\n   */\n\n  function patch (entityId, prev, next, el) {\n    return diffNode('0', entityId, prev, next, el)\n  }\n\n  /**\n   * Create a diff between two trees of nodes.\n   */\n\n  function diffNode (path, entityId, prev, next, el) {\n    var leftType = nodeType(prev)\n    var rightType = nodeType(next)\n\n    // Type changed. This could be from element->text, text->ComponentA,\n    // ComponentA->ComponentB etc. But NOT div->span. These are the same type\n    // (ElementNode) but different tag name.\n    if (leftType !== rightType) return replaceElement(entityId, path, el, next)\n\n    switch (rightType) {\n      case 'text': return diffText(prev, next, el)\n      case 'empty': return el\n      case 'element': return diffElement(path, entityId, prev, next, el)\n      case 'component': return diffComponent(path, entityId, prev, next, el)\n    }\n  }\n\n  /**\n   * Diff two text nodes and update the element.\n   */\n\n  function diffText (previous, current, el) {\n    if (current !== previous) el.data = current\n    return el\n  }\n\n  /**\n   * Diff the children of an ElementNode.\n   */\n\n  function diffChildren (path, entityId, prev, next, el) {\n    var positions = []\n    var hasKeys = false\n    var childNodes = Array.prototype.slice.apply(el.childNodes)\n    var leftKeys = reduce(prev.children, keyMapReducer, {})\n    var rightKeys = reduce(next.children, keyMapReducer, {})\n    var currentChildren = assign({}, children[entityId])\n\n    function keyMapReducer (acc, child, i) {\n      if (child && child.attributes && child.attributes.key != null) {\n        acc[child.attributes.key] = {\n          element: child,\n          index: i\n        }\n        hasKeys = true\n      }\n      return acc\n    }\n\n    // Diff all of the nodes that have keys. This lets us re-used elements\n    // instead of overriding them and lets us move them around.\n    if (hasKeys) {\n\n      // Removals\n      forEach(leftKeys, function (leftNode, key) {\n        if (rightKeys[key] == null) {\n          var leftPath = path + '.' + leftNode.index\n          removeElement(\n            entityId,\n            leftPath,\n            childNodes[leftNode.index]\n          )\n        }\n      })\n\n      // Update nodes\n      forEach(rightKeys, function (rightNode, key) {\n        var leftNode = leftKeys[key]\n\n        // We only want updates for now\n        if (leftNode == null) return\n\n        var leftPath = path + '.' + leftNode.index\n\n        // Updated\n        positions[rightNode.index] = diffNode(\n          leftPath,\n          entityId,\n          leftNode.element,\n          rightNode.element,\n          childNodes[leftNode.index]\n        )\n      })\n\n      // Update the positions of all child components and event handlers\n      forEach(rightKeys, function (rightNode, key) {\n        var leftNode = leftKeys[key]\n\n        // We just want elements that have moved around\n        if (leftNode == null || leftNode.index === rightNode.index) return\n\n        var rightPath = path + '.' + rightNode.index\n        var leftPath = path + '.' + leftNode.index\n\n        // Update all the child component path positions to match\n        // the latest positions if they've changed. This is a bit hacky.\n        forEach(currentChildren, function (childId, childPath) {\n          if (leftPath === childPath) {\n            delete children[entityId][childPath]\n            children[entityId][rightPath] = childId\n          }\n        })\n      })\n\n      // Now add all of the new nodes last in case their path\n      // would have conflicted with one of the previous paths.\n      forEach(rightKeys, function (rightNode, key) {\n        var rightPath = path + '.' + rightNode.index\n        if (leftKeys[key] == null) {\n          positions[rightNode.index] = toNative(\n            entityId,\n            rightPath,\n            rightNode.element\n          )\n        }\n      })\n\n    } else {\n      var maxLength = Math.max(prev.children.length, next.children.length)\n\n      // Now diff all of the nodes that don't have keys\n      for (var i = 0; i < maxLength; i++) {\n        var leftNode = prev.children[i]\n        var rightNode = next.children[i]\n\n        // Removals\n        if (rightNode === undefined) {\n          removeElement(\n            entityId,\n            path + '.' + i,\n            childNodes[i]\n          )\n          continue\n        }\n\n        // New Node\n        if (leftNode === undefined) {\n          positions[i] = toNative(\n            entityId,\n            path + '.' + i,\n            rightNode\n          )\n          continue\n        }\n\n        // Updated\n        positions[i] = diffNode(\n          path + '.' + i,\n          entityId,\n          leftNode,\n          rightNode,\n          childNodes[i]\n        )\n      }\n    }\n\n    // Reposition all the elements\n    forEach(positions, function (childEl, newPosition) {\n      var target = el.childNodes[newPosition]\n      if (childEl && childEl !== target) {\n        if (target) {\n          el.insertBefore(childEl, target)\n        } else {\n          el.appendChild(childEl)\n        }\n      }\n    })\n  }\n\n  /**\n   * Diff the attributes and add/remove them.\n   */\n\n  function diffAttributes (prev, next, el, entityId, path) {\n    var nextAttrs = next.attributes\n    var prevAttrs = prev.attributes\n\n    // add new attrs\n    forEach(nextAttrs, function (value, name) {\n      if (events[name] || !(name in prevAttrs) || prevAttrs[name] !== value) {\n        setAttribute(entityId, path, el, name, value)\n      }\n    })\n\n    // remove old attrs\n    forEach(prevAttrs, function (value, name) {\n      if (!(name in nextAttrs)) {\n        removeAttribute(entityId, path, el, name)\n      }\n    })\n  }\n\n  /**\n   * Update a component with the props from the next node. If\n   * the component type has changed, we'll just remove the old one\n   * and replace it with the new component.\n   */\n\n  function diffComponent (path, entityId, prev, next, el) {\n    if (next.type !== prev.type) {\n      return replaceElement(entityId, path, el, next)\n    } else {\n      var targetId = children[entityId][path]\n\n      // This is a hack for now\n      if (targetId) {\n        updateEntityProps(targetId, assign({ children: next.children }, next.attributes))\n      }\n\n      return el\n    }\n  }\n\n  /**\n   * Diff two element nodes.\n   */\n\n  function diffElement (path, entityId, prev, next, el) {\n    if (next.type !== prev.type) return replaceElement(entityId, path, el, next)\n    diffAttributes(prev, next, el, entityId, path)\n    diffChildren(path, entityId, prev, next, el)\n    return el\n  }\n\n  /**\n   * Removes an element from the DOM and unmounts and components\n   * that are within that branch\n   *\n   * side effects:\n   *   - removes element from the DOM\n   *   - removes internal references\n   *\n   * @param {String} entityId\n   * @param {String} path\n   * @param {HTMLElement} el\n   */\n\n  function removeElement (entityId, path, el) {\n    var childrenByPath = children[entityId]\n    var childId = childrenByPath[path]\n    var entityHandlers = handlers[entityId] || {}\n    var removals = []\n\n    // If the path points to a component we should use that\n    // components element instead, because it might have moved it.\n    if (childId) {\n      var child = entities[childId]\n      el = child.nativeElement\n      unmountEntity(childId)\n      removals.push(path)\n    } else {\n\n      // Just remove the text node\n      if (!isElement(el)) return el && el.parentNode.removeChild(el)\n\n      // Then we need to find any components within this\n      // branch and unmount them.\n      forEach(childrenByPath, function (childId, childPath) {\n        if (childPath === path || isWithinPath(path, childPath)) {\n          unmountEntity(childId)\n          removals.push(childPath)\n        }\n      })\n\n      // Remove all events at this path or below it\n      forEach(entityHandlers, function (fn, handlerPath) {\n        if (handlerPath === path || isWithinPath(path, handlerPath)) {\n          removeEvent(entityId, handlerPath)\n        }\n      })\n    }\n\n    // Remove the paths from the object without touching the\n    // old object. This keeps the object using fast properties.\n    forEach(removals, function (path) {\n      delete children[entityId][path]\n    })\n\n    // Remove it from the DOM\n    el.parentNode.removeChild(el)\n  }\n\n  /**\n   * Replace an element in the DOM. Removing all components\n   * within that element and re-rendering the new virtual node.\n   *\n   * @param {Entity} entity\n   * @param {String} path\n   * @param {HTMLElement} el\n   * @param {Object} vnode\n   *\n   * @return {void}\n   */\n\n  function replaceElement (entityId, path, el, vnode) {\n    var parent = el.parentNode\n    var index = Array.prototype.indexOf.call(parent.childNodes, el)\n\n    // remove the previous element and all nested components. This\n    // needs to happen before we create the new element so we don't\n    // get clashes on the component paths.\n    removeElement(entityId, path, el)\n\n    // then add the new element in there\n    var newEl = toNative(entityId, path, vnode)\n    var target = parent.childNodes[index]\n\n    if (target) {\n      parent.insertBefore(newEl, target)\n    } else {\n      parent.appendChild(newEl)\n    }\n\n    // walk up the tree and update all `entity.nativeElement` references.\n    if (entityId !== 'root' && path === '0') {\n      updateNativeElement(entityId, newEl)\n    }\n\n    return newEl\n  }\n\n  /**\n   * Update all entities in a branch that have the same nativeElement. This\n   * happens when a component has another component as it's root node.\n   *\n   * @param {String} entityId\n   * @param {HTMLElement} newEl\n   *\n   * @return {void}\n   */\n\n  function updateNativeElement (entityId, newEl) {\n    var target = entities[entityId]\n    if (target.ownerId === 'root') return\n    if (children[target.ownerId]['0'] === entityId) {\n      entities[target.ownerId].nativeElement = newEl\n      updateNativeElement(target.ownerId, newEl)\n    }\n  }\n\n  /**\n   * Set the attribute of an element, performing additional transformations\n   * dependning on the attribute name\n   *\n   * @param {HTMLElement} el\n   * @param {String} name\n   * @param {String} value\n   */\n\n  function setAttribute (entityId, path, el, name, value) {\n    if (!value) {\n      removeAttribute(entityId, path, el, name)\n      return\n    }\n    if (events[name]) {\n      addEvent(entityId, path, events[name], value)\n      return\n    }\n    switch (name) {\n      case 'checked':\n      case 'disabled':\n      case 'selected':\n        el[name] = true\n        break\n      case 'innerHTML':\n        el.innerHTML = value\n        break\n      case 'value':\n        setElementValue(el, value)\n        break\n      case svg.isAttribute(name):\n        el.setAttributeNS(svg.namespace, name, value)\n        break\n      default:\n        el.setAttribute(name, value)\n        break\n    }\n  }\n\n  /**\n   * Remove an attribute, performing additional transformations\n   * dependning on the attribute name\n   *\n   * @param {HTMLElement} el\n   * @param {String} name\n   */\n\n  function removeAttribute (entityId, path, el, name) {\n    if (events[name]) {\n      removeEvent(entityId, path, events[name])\n      return\n    }\n    switch (name) {\n      case 'checked':\n      case 'disabled':\n      case 'selected':\n        el[name] = false\n        break\n      case 'innerHTML':\n        el.innerHTML = ''\n      case 'value':\n        setElementValue(el, null)\n        break\n      default:\n        el.removeAttribute(name)\n        break\n    }\n  }\n\n  /**\n   * Checks to see if one tree path is within\n   * another tree path. Example:\n   *\n   * 0.1 vs 0.1.1 = true\n   * 0.2 vs 0.3.5 = false\n   *\n   * @param {String} target\n   * @param {String} path\n   *\n   * @return {Boolean}\n   */\n\n  function isWithinPath (target, path) {\n    return path.indexOf(target + '.') === 0\n  }\n\n  /**\n   * Is the DOM node an element node\n   *\n   * @param {HTMLElement} el\n   *\n   * @return {Boolean}\n   */\n\n  function isElement (el) {\n    return !!(el && el.tagName)\n  }\n\n  /**\n   * Remove all the child nodes from an element\n   *\n   * @param {HTMLElement} el\n   */\n\n  function removeAllChildren (el) {\n    while (el.firstChild) el.removeChild(el.firstChild)\n  }\n\n  /**\n   * Trigger a hook on a component.\n   *\n   * @param {String} name Name of hook.\n   * @param {Entity} entity The component instance.\n   * @param {Array} args To pass along to hook.\n   */\n\n  function trigger (name, entity, args) {\n    if (typeof entity.component[name] !== 'function') return\n    return entity.component[name].apply(null, args)\n  }\n\n  /**\n   * Update an entity to match the latest rendered vode. We always\n   * replace the props on the component when composing them. This\n   * will trigger a re-render on all children below this point.\n   *\n   * @param {Entity} entity\n   * @param {String} path\n   * @param {Object} vnode\n   *\n   * @return {void}\n   */\n\n  function updateEntityProps (entityId, nextProps) {\n    var entity = entities[entityId]\n    entity.pendingProps = defaults({}, nextProps, entity.component.defaultProps || {})\n    entity.dirty = true\n    invalidate()\n  }\n\n  /**\n   * Update component instance state.\n   */\n\n  function updateEntityState (entity, nextState) {\n    entity.pendingState = assign(entity.pendingState, nextState)\n    entity.dirty = true\n    invalidate()\n  }\n\n  /**\n   * Commit props and state changes to an entity.\n   */\n\n  function commit (entity) {\n    entity.context = {\n      state: entity.pendingState,\n      props: entity.pendingProps,\n      id: entity.id\n    }\n    entity.pendingState = assign({}, entity.context.state)\n    entity.pendingProps = assign({}, entity.context.props)\n    entity.dirty = false\n    if (typeof entity.component.validate === 'function') {\n      entity.component.validate(entity.context)\n    }\n  }\n\n  /**\n   * Try to avoid creating new virtual dom if possible.\n   *\n   * Later we may expose this so you can override, but not there yet.\n   */\n\n  function shouldUpdate (entity) {\n    if (!entity.dirty) return false\n    if (!entity.component.shouldUpdate) return true\n    var nextProps = entity.pendingProps\n    var nextState = entity.pendingState\n    var bool = entity.component.shouldUpdate(entity.context, nextProps, nextState)\n    return bool\n  }\n\n  /**\n   * Register an entity.\n   *\n   * This is mostly to pre-preprocess component properties and values chains.\n   *\n   * The end result is for every component that gets mounted,\n   * you create a set of IO nodes in the network from the `value` definitions.\n   *\n   * @param {Component} component\n   */\n\n  function register (entity) {\n    registerEntity(entity)\n    var component = entity.component\n    if (component.registered) return\n\n    // initialize sources once for a component type.\n    registerSources(entity)\n    component.registered = true\n  }\n\n  /**\n   * Add entity to data-structures related to components/entities.\n   *\n   * @param {Entity} entity\n   */\n\n  function registerEntity(entity) {\n    var component = entity.component\n    // all entities for this component type.\n    var entities = component.entities = component.entities || {}\n    // add entity to component list\n    entities[entity.id] = entity\n    // map to component so you can remove later.\n    components[entity.id] = component\n  }\n\n  /**\n   * Initialize sources for a component by type.\n   *\n   * @param {Entity} entity\n   */\n\n  function registerSources(entity) {\n    var component = components[entity.id]\n    // get 'class-level' sources.\n    // if we've already hooked it up, then we're good.\n    var sources = component.sources\n    if (sources) return\n    var entities = component.entities\n\n    // hook up sources.\n    var map = component.sourceToPropertyName = {}\n    component.sources = sources = []\n    var propTypes = component.propTypes\n    for (var name in propTypes) {\n      var data = propTypes[name]\n      if (!data) continue\n      if (!data.source) continue\n      sources.push(data.source)\n      map[data.source] = name\n    }\n\n    // send value updates to all component instances.\n    sources.forEach(function (source) {\n      connections[source] = connections[source] || []\n      connections[source].push(update)\n\n      function update (data) {\n        var prop = map[source]\n        for (var entityId in entities) {\n          var entity = entities[entityId]\n          var changes = {}\n          changes[prop] = data\n          updateEntityProps(entityId, assign(entity.pendingProps, changes))\n        }\n      }\n    })\n  }\n\n  /**\n   * Set the initial source value on the entity\n   *\n   * @param {Entity} entity\n   */\n\n  function setSources (entity) {\n    var component = entity.component\n    var map = component.sourceToPropertyName\n    var sources = component.sources\n    sources.forEach(function (source) {\n      var name = map[source]\n      if (entity.pendingProps[name] != null) return\n      entity.pendingProps[name] = app.sources[source] // get latest value plugged into global store\n    })\n  }\n\n  /**\n   * Add all of the DOM event listeners\n   */\n\n  function addNativeEventListeners () {\n    forEach(events, function (eventType) {\n      rootElement.addEventListener(eventType, handleEvent, true)\n    })\n  }\n\n  /**\n   * Add all of the DOM event listeners\n   */\n\n  function removeNativeEventListeners () {\n    forEach(events, function (eventType) {\n      rootElement.removeEventListener(eventType, handleEvent, true)\n    })\n  }\n\n  /**\n   * Handle an event that has occured within the container\n   *\n   * @param {Event} event\n   */\n\n  function handleEvent (event) {\n    var target = event.target\n    var eventType = event.type\n\n    // Walk up the DOM tree and see if there is a handler\n    // for this event type higher up.\n    while (target) {\n      var fn = keypath.get(handlers, [target.__entity__, target.__path__, eventType])\n      if (fn) {\n        event.delegateTarget = target\n        if (fn(event) === false) break\n      }\n      target = target.parentNode\n    }\n  }\n\n  /**\n   * Bind events for an element, and all it's rendered child elements.\n   *\n   * @param {String} path\n   * @param {String} event\n   * @param {Function} fn\n   */\n\n  function addEvent (entityId, path, eventType, fn) {\n    keypath.set(handlers, [entityId, path, eventType], function (e) {\n      var entity = entities[entityId]\n      if (entity) {\n        return fn.call(null, e, entity.context, setState(entity))\n      } else {\n        return fn.call(null, e)\n      }\n    })\n  }\n\n  /**\n   * Unbind events for a entityId\n   *\n   * @param {String} entityId\n   */\n\n  function removeEvent (entityId, path, eventType) {\n    var args = [entityId]\n    if (path) args.push(path)\n    if (eventType) args.push(eventType)\n    keypath.del(handlers, args)\n  }\n\n  /**\n   * Unbind all events from an entity\n   *\n   * @param {Entity} entity\n   */\n\n  function removeAllEvents (entityId) {\n    keypath.del(handlers, [entityId])\n  }\n\n  /**\n   * Used for debugging to inspect the current state without\n   * us needing to explicitly manage storing/updating references.\n   *\n   * @return {Object}\n   */\n\n  function inspect () {\n    return {\n      entities: entities,\n      handlers: handlers,\n      connections: connections,\n      currentElement: currentElement,\n      options: options,\n      app: app,\n      container: container,\n      children: children\n    }\n  }\n\n  /**\n   * Return an object that lets us completely remove the automatic\n   * DOM rendering and export debugging tools.\n   */\n\n  return {\n    remove: teardown,\n    inspect: inspect\n  }\n}\n\n/**\n * A rendered component instance.\n *\n * This manages the lifecycle, props and state of the component.\n * It's basically just a data object for more straightfoward lookup.\n *\n * @param {Component} component\n * @param {Object} props\n */\n\nfunction Entity (component, props, ownerId) {\n  this.id = uid()\n  this.ownerId = ownerId\n  this.component = component\n  this.propTypes = component.propTypes || {}\n  this.context = {}\n  this.context.id = this.id\n  this.context.props = defaults(props || {}, component.defaultProps || {})\n  this.context.state = this.component.initialState ? this.component.initialState(this.context.props) : {}\n  this.pendingProps = assign({}, this.context.props)\n  this.pendingState = assign({}, this.context.state)\n  this.dirty = false\n  this.virtualElement = null\n  this.nativeElement = null\n  this.displayName = component.name || 'Component'\n}\n\n/**\n * Retrieve the nearest 'body' ancestor of the given element or else the root\n * element of the document in which stands the given element.\n *\n * This is necessary if you want to attach the events handler to the correct\n * element and be able to dispatch events in document fragments such as\n * Shadow DOM.\n *\n * @param  {HTMLElement} el The element on which we will render an app.\n * @return {HTMLElement}    The root element on which we will attach the events\n *                          handler.\n */\n\nfunction getRootElement (el) {\n  while (el.parentElement) {\n    if (el.tagName === 'BODY' || !el.parentElement) {\n      return el\n    }\n    el = el.parentElement\n  }\n  return el\n}\n\n/**\n * Set the value property of an element and keep the text selection\n * for input fields.\n *\n * @param {HTMLElement} el\n * @param {String} value\n */\n\nfunction setElementValue (el, value) {\n  if (el === document.activeElement && canSelectText(el)) {\n    var start = el.selectionStart\n    var end = el.selectionEnd\n    el.value = value\n    el.setSelectionRange(start, end)\n  } else {\n    el.value = value\n  }\n}\n\n/**\n * For some reason only certain types of inputs can set the selection range.\n *\n * @param {HTMLElement} el\n *\n * @return {Boolean}\n */\n\nfunction canSelectText (el) {\n  return el.tagName === 'INPUT' && ['text','search','password','tel','url'].indexOf(el.type) > -1\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/deku/lib/render.js\n ** module id = 5\n ** module chunks = 0\n **/","/**\n * Expose `requestAnimationFrame()`.\n */\n\nexports = module.exports = window.requestAnimationFrame\n  || window.webkitRequestAnimationFrame\n  || window.mozRequestAnimationFrame\n  || fallback;\n\n/**\n * Fallback implementation.\n */\n\nvar prev = new Date().getTime();\nfunction fallback(fn) {\n  var curr = new Date().getTime();\n  var ms = Math.max(0, 16 - (curr - prev));\n  var req = setTimeout(fn, ms);\n  prev = curr;\n  return req;\n}\n\n/**\n * Cancel.\n */\n\nvar cancel = window.cancelAnimationFrame\n  || window.webkitCancelAnimationFrame\n  || window.mozCancelAnimationFrame\n  || window.clearTimeout;\n\nexports.cancel = function(id){\n  cancel.call(window, id);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/component-raf/index.js\n ** module id = 6\n ** module chunks = 0\n **/","/*global window*/\n\n/**\n * Check if object is dom node.\n *\n * @param {Object} val\n * @return {Boolean}\n * @api public\n */\n\nmodule.exports = function isNode(val){\n  if (!val || typeof val !== 'object') return false;\n  if (window && 'object' == typeof window.Node) return val instanceof window.Node;\n  return 'number' == typeof val.nodeType && 'string' == typeof val.nodeName;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/is-dom/index.js\n ** module id = 7\n ** module chunks = 0\n **/","/** generate unique id for selector */\r\nvar counter = Date.now() % 1e9;\r\n\r\nmodule.exports = function getUid(){\r\n\treturn (Math.random() * 1e9 >>> 0) + (counter++);\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/get-uid/index.js\n ** module id = 8\n ** module chunks = 0\n **/","(function (root, factory){\n  'use strict';\n\n  /*istanbul ignore next:cant test*/\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = factory();\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else {\n    // Browser globals\n    root.objectPath = factory();\n  }\n})(this, function(){\n  'use strict';\n\n  var\n    toStr = Object.prototype.toString,\n    _hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  function isEmpty(value){\n    if (!value) {\n      return true;\n    }\n    if (isArray(value) && value.length === 0) {\n        return true;\n    } else if (!isString(value)) {\n        for (var i in value) {\n            if (_hasOwnProperty.call(value, i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n  }\n\n  function toString(type){\n    return toStr.call(type);\n  }\n\n  function isNumber(value){\n    return typeof value === 'number' || toString(value) === \"[object Number]\";\n  }\n\n  function isString(obj){\n    return typeof obj === 'string' || toString(obj) === \"[object String]\";\n  }\n\n  function isObject(obj){\n    return typeof obj === 'object' && toString(obj) === \"[object Object]\";\n  }\n\n  function isArray(obj){\n    return typeof obj === 'object' && typeof obj.length === 'number' && toString(obj) === '[object Array]';\n  }\n\n  function isBoolean(obj){\n    return typeof obj === 'boolean' || toString(obj) === '[object Boolean]';\n  }\n\n  function getKey(key){\n    var intKey = parseInt(key);\n    if (intKey.toString() === key) {\n      return intKey;\n    }\n    return key;\n  }\n\n  function set(obj, path, value, doNotReplace){\n    if (isNumber(path)) {\n      path = [path];\n    }\n    if (isEmpty(path)) {\n      return obj;\n    }\n    if (isString(path)) {\n      return set(obj, path.split('.').map(getKey), value, doNotReplace);\n    }\n    var currentPath = path[0];\n\n    if (path.length === 1) {\n      var oldVal = obj[currentPath];\n      if (oldVal === void 0 || !doNotReplace) {\n        obj[currentPath] = value;\n      }\n      return oldVal;\n    }\n\n    if (obj[currentPath] === void 0) {\n      //check if we assume an array\n      if(isNumber(path[1])) {\n        obj[currentPath] = [];\n      } else {\n        obj[currentPath] = {};\n      }\n    }\n\n    return set(obj[currentPath], path.slice(1), value, doNotReplace);\n  }\n\n  function del(obj, path) {\n    if (isNumber(path)) {\n      path = [path];\n    }\n\n    if (isEmpty(obj)) {\n      return void 0;\n    }\n\n    if (isEmpty(path)) {\n      return obj;\n    }\n    if(isString(path)) {\n      return del(obj, path.split('.'));\n    }\n\n    var currentPath = getKey(path[0]);\n    var oldVal = obj[currentPath];\n\n    if(path.length === 1) {\n      if (oldVal !== void 0) {\n        if (isArray(obj)) {\n          obj.splice(currentPath, 1);\n        } else {\n          delete obj[currentPath];\n        }\n      }\n    } else {\n      if (obj[currentPath] !== void 0) {\n        return del(obj[currentPath], path.slice(1));\n      }\n    }\n\n    return obj;\n  }\n\n  var objectPath = function(obj) {\n    return Object.keys(objectPath).reduce(function(proxy, prop) {\n      if (typeof objectPath[prop] === 'function') {\n        proxy[prop] = objectPath[prop].bind(objectPath, obj);\n      }\n\n      return proxy;\n    }, {});\n  };\n\n  objectPath.has = function (obj, path) {\n    if (isEmpty(obj)) {\n      return false;\n    }\n\n    if (isNumber(path)) {\n      path = [path];\n    } else if (isString(path)) {\n      path = path.split('.');\n    }\n\n    if (isEmpty(path) || path.length === 0) {\n      return false;\n    }\n\n    for (var i = 0; i < path.length; i++) {\n      var j = path[i];\n      if ((isObject(obj) || isArray(obj)) && _hasOwnProperty.call(obj, j)) {\n        obj = obj[j];\n      } else {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  objectPath.ensureExists = function (obj, path, value){\n    return set(obj, path, value, true);\n  };\n\n  objectPath.set = function (obj, path, value, doNotReplace){\n    return set(obj, path, value, doNotReplace);\n  };\n\n  objectPath.insert = function (obj, path, value, at){\n    var arr = objectPath.get(obj, path);\n    at = ~~at;\n    if (!isArray(arr)) {\n      arr = [];\n      objectPath.set(obj, path, arr);\n    }\n    arr.splice(at, 0, value);\n  };\n\n  objectPath.empty = function(obj, path) {\n    if (isEmpty(path)) {\n      return obj;\n    }\n    if (isEmpty(obj)) {\n      return void 0;\n    }\n\n    var value, i;\n    if (!(value = objectPath.get(obj, path))) {\n      return obj;\n    }\n\n    if (isString(value)) {\n      return objectPath.set(obj, path, '');\n    } else if (isBoolean(value)) {\n      return objectPath.set(obj, path, false);\n    } else if (isNumber(value)) {\n      return objectPath.set(obj, path, 0);\n    } else if (isArray(value)) {\n      value.length = 0;\n    } else if (isObject(value)) {\n      for (i in value) {\n        if (_hasOwnProperty.call(value, i)) {\n          delete value[i];\n        }\n      }\n    } else {\n      return objectPath.set(obj, path, null);\n    }\n  };\n\n  objectPath.push = function (obj, path /*, values */){\n    var arr = objectPath.get(obj, path);\n    if (!isArray(arr)) {\n      arr = [];\n      objectPath.set(obj, path, arr);\n    }\n\n    arr.push.apply(arr, Array.prototype.slice.call(arguments, 2));\n  };\n\n  objectPath.coalesce = function (obj, paths, defaultValue) {\n    var value;\n\n    for (var i = 0, len = paths.length; i < len; i++) {\n      if ((value = objectPath.get(obj, paths[i])) !== void 0) {\n        return value;\n      }\n    }\n\n    return defaultValue;\n  };\n\n  objectPath.get = function (obj, path, defaultValue){\n    if (isNumber(path)) {\n      path = [path];\n    }\n    if (isEmpty(path)) {\n      return obj;\n    }\n    if (isEmpty(obj)) {\n      return defaultValue;\n    }\n    if (isString(path)) {\n      return objectPath.get(obj, path.split('.'), defaultValue);\n    }\n\n    var currentPath = getKey(path[0]);\n\n    if (path.length === 1) {\n      if (obj[currentPath] === void 0) {\n        return defaultValue;\n      }\n      return obj[currentPath];\n    }\n\n    return objectPath.get(obj[currentPath], path.slice(1), defaultValue);\n  };\n\n  objectPath.del = function(obj, path) {\n    return del(obj, path);\n  };\n\n  return objectPath;\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/object-path/index.js\n ** module id = 9\n ** module chunks = 0\n **/","/**\n * All of the events can bind to\n */\n\nmodule.exports = {\n  onBlur: 'blur',\n  onChange: 'change',\n  onClick: 'click',\n  onContextMenu: 'contextmenu',\n  onCopy: 'copy',\n  onCut: 'cut',\n  onDoubleClick: 'dblclick',\n  onDrag: 'drag',\n  onDragEnd: 'dragend',\n  onDragEnter: 'dragenter',\n  onDragExit: 'dragexit',\n  onDragLeave: 'dragleave',\n  onDragOver: 'dragover',\n  onDragStart: 'dragstart',\n  onDrop: 'drop',\n  onError: 'error',\n  onFocus: 'focus',\n  onInput: 'input',\n  onInvalid: 'invalid',\n  onKeyDown: 'keydown',\n  onKeyPress: 'keypress',\n  onKeyUp: 'keyup',\n  onMouseDown: 'mousedown',\n  onMouseEnter: 'mouseenter',\n  onMouseLeave: 'mouseleave',\n  onMouseMove: 'mousemove',\n  onMouseOut: 'mouseout',\n  onMouseOver: 'mouseover',\n  onMouseUp: 'mouseup',\n  onPaste: 'paste',\n  onReset: 'reset',\n  onScroll: 'scroll',\n  onSubmit: 'submit',\n  onTouchCancel: 'touchcancel',\n  onTouchEnd: 'touchend',\n  onTouchMove: 'touchmove',\n  onTouchStart: 'touchstart',\n  onWheel: 'wheel'\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/deku/lib/events.js\n ** module id = 10\n ** module chunks = 0\n **/","module.exports = {\n  isElement: require('is-svg-element').isElement,\n  isAttribute: require('is-svg-attribute'),\n  namespace: 'http://www.w3.org/2000/svg'\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/deku/lib/svg.js\n ** module id = 11\n ** module chunks = 0\n **/","/**\n * Supported SVG elements\n *\n * @type {Array}\n */\n\nexports.elements = {\n  'animate': true,\n  'circle': true,\n  'defs': true,\n  'ellipse': true,\n  'g': true,\n  'line': true,\n  'linearGradient': true,\n  'mask': true,\n  'path': true,\n  'pattern': true,\n  'polygon': true,\n  'polyline': true,\n  'radialGradient': true,\n  'rect': true,\n  'stop': true,\n  'svg': true,\n  'text': true,\n  'tspan': true\n}\n\n/**\n * Is element's namespace SVG?\n *\n * @param {String} name\n */\n\nexports.isElement = function (name) {\n  return name in exports.elements\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/is-svg-element/index.js\n ** module id = 12\n ** module chunks = 0\n **/","/**\n * Supported SVG attributes\n */\n\nexports.attributes = {\n  'cx': true,\n  'cy': true,\n  'd': true,\n  'dx': true,\n  'dy': true,\n  'fill': true,\n  'fillOpacity': true,\n  'fontFamily': true,\n  'fontSize': true,\n  'fx': true,\n  'fy': true,\n  'gradientTransform': true,\n  'gradientUnits': true,\n  'markerEnd': true,\n  'markerMid': true,\n  'markerStart': true,\n  'offset': true,\n  'opacity': true,\n  'patternContentUnits': true,\n  'patternUnits': true,\n  'points': true,\n  'preserveAspectRatio': true,\n  'r': true,\n  'rx': true,\n  'ry': true,\n  'spreadMethod': true,\n  'stopColor': true,\n  'stopOpacity': true,\n  'stroke': true,\n  'strokeDasharray': true,\n  'strokeLinecap': true,\n  'strokeOpacity': true,\n  'strokeWidth': true,\n  'textAnchor': true,\n  'transform': true,\n  'version': true,\n  'viewBox': true,\n  'x1': true,\n  'x2': true,\n  'x': true,\n  'y1': true,\n  'y2': true,\n  'y': true\n}\n\n/**\n * Are element's attributes SVG?\n *\n * @param {String} attr\n */\n\nmodule.exports = function (attr) {\n  return attr in exports.attributes\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/is-svg-attribute/index.js\n ** module id = 13\n ** module chunks = 0\n **/","'use strict'\n\nmodule.exports = function(target) {\n  target = target || {}\n\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i]\n    if (!source) continue\n\n    Object.getOwnPropertyNames(source).forEach(function(key) {\n      if (undefined === target[key])\n        target[key] = source[key]\n    })\n  }\n\n  return target\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/object-defaults/index.js\n ** module id = 14\n ** module chunks = 0\n **/","'use strict';\n\nvar forEachArray = require('./array/forEach'),\n    forEachObject = require('./object/forEach');\n\n/**\n * # ForEach\n *\n * A fast `.forEach()` implementation.\n *\n * @param  {Array|Object} subject     The array or object to iterate over.\n * @param  {Function}     fn          The visitor function.\n * @param  {Object}       thisContext The context for the visitor.\n */\nmodule.exports = function fastForEach (subject, fn, thisContext) {\n  if (subject instanceof Array) {\n    return forEachArray(subject, fn, thisContext);\n  }\n  else {\n    return forEachObject(subject, fn, thisContext);\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/fast.js/forEach.js\n ** module id = 15\n ** module chunks = 0\n **/","'use strict';\n\nvar bindInternal3 = require('../function/bindInternal3');\n\n/**\n * # For Each\n *\n * A fast `.forEach()` implementation.\n *\n * @param  {Array}    subject     The array (or array-like) to iterate over.\n * @param  {Function} fn          The visitor function.\n * @param  {Object}   thisContext The context for the visitor.\n */\nmodule.exports = function fastForEach (subject, fn, thisContext) {\n  var length = subject.length,\n      iterator = thisContext !== undefined ? bindInternal3(fn, thisContext) : fn,\n      i;\n  for (i = 0; i < length; i++) {\n    iterator(subject[i], i, subject);\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/fast.js/array/forEach.js\n ** module id = 16\n ** module chunks = 0\n **/","'use strict';\n\n/**\n * Internal helper to bind a function known to have 3 arguments\n * to a given context.\n */\nmodule.exports = function bindInternal3 (func, thisContext) {\n  return function (a, b, c) {\n    return func.call(thisContext, a, b, c);\n  };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/fast.js/function/bindInternal3.js\n ** module id = 17\n ** module chunks = 0\n **/","'use strict';\n\nvar bindInternal3 = require('../function/bindInternal3');\n\n/**\n * # For Each\n *\n * A fast object `.forEach()` implementation.\n *\n * @param  {Object}   subject     The object to iterate over.\n * @param  {Function} fn          The visitor function.\n * @param  {Object}   thisContext The context for the visitor.\n */\nmodule.exports = function fastForEachObject (subject, fn, thisContext) {\n  var keys = Object.keys(subject),\n      length = keys.length,\n      iterator = thisContext !== undefined ? bindInternal3(fn, thisContext) : fn,\n      key, i;\n  for (i = 0; i < length; i++) {\n    key = keys[i];\n    iterator(subject[key], key, subject);\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/fast.js/object/forEach.js\n ** module id = 18\n ** module chunks = 0\n **/","'use strict';\n\n/**\n * Analogue of Object.assign().\n * Copies properties from one or more source objects to\n * a target object. Existing keys on the target object will be overwritten.\n *\n * > Note: This differs from spec in some important ways:\n * > 1. Will throw if passed non-objects, including `undefined` or `null` values.\n * > 2. Does not support the curious Exception handling behavior, exceptions are thrown immediately.\n * > For more details, see:\n * > https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n *\n *\n *\n * @param  {Object} target      The target object to copy properties to.\n * @param  {Object} source, ... The source(s) to copy properties from.\n * @return {Object}             The updated target object.\n */\nmodule.exports = function fastAssign (target) {\n  var totalArgs = arguments.length,\n      source, i, totalKeys, keys, key, j;\n\n  for (i = 1; i < totalArgs; i++) {\n    source = arguments[i];\n    keys = Object.keys(source);\n    totalKeys = keys.length;\n    for (j = 0; j < totalKeys; j++) {\n      key = keys[j];\n      target[key] = source[key];\n    }\n  }\n  return target;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/fast.js/object/assign.js\n ** module id = 19\n ** module chunks = 0\n **/","'use strict';\n\nvar reduceArray = require('./array/reduce'),\n    reduceObject = require('./object/reduce');\n\n/**\n * # Reduce\n *\n * A fast `.reduce()` implementation.\n *\n * @param  {Array|Object} subject      The array or object to reduce over.\n * @param  {Function}     fn           The reducer function.\n * @param  {mixed}        initialValue The initial value for the reducer, defaults to subject[0].\n * @param  {Object}       thisContext  The context for the reducer.\n * @return {Array|Object}              The array or object containing the results.\n */\nmodule.exports = function fastReduce (subject, fn, initialValue, thisContext) {\n  if (subject instanceof Array) {\n    return reduceArray(subject, fn, initialValue, thisContext);\n  }\n  else {\n    return reduceObject(subject, fn, initialValue, thisContext);\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/fast.js/reduce.js\n ** module id = 20\n ** module chunks = 0\n **/","'use strict';\n\nvar bindInternal4 = require('../function/bindInternal4');\n\n/**\n * # Reduce\n *\n * A fast `.reduce()` implementation.\n *\n * @param  {Array}    subject      The array (or array-like) to reduce.\n * @param  {Function} fn           The reducer function.\n * @param  {mixed}    initialValue The initial value for the reducer, defaults to subject[0].\n * @param  {Object}   thisContext  The context for the reducer.\n * @return {mixed}                 The final result.\n */\nmodule.exports = function fastReduce (subject, fn, initialValue, thisContext) {\n  var length = subject.length,\n      iterator = thisContext !== undefined ? bindInternal4(fn, thisContext) : fn,\n      i, result;\n\n  if (initialValue === undefined) {\n    i = 1;\n    result = subject[0];\n  }\n  else {\n    i = 0;\n    result = initialValue;\n  }\n\n  for (; i < length; i++) {\n    result = iterator(result, subject[i], i, subject);\n  }\n\n  return result;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/fast.js/array/reduce.js\n ** module id = 21\n ** module chunks = 0\n **/","'use strict';\n\n/**\n * Internal helper to bind a function known to have 4 arguments\n * to a given context.\n */\nmodule.exports = function bindInternal4 (func, thisContext) {\n  return function (a, b, c, d) {\n    return func.call(thisContext, a, b, c, d);\n  };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/fast.js/function/bindInternal4.js\n ** module id = 22\n ** module chunks = 0\n **/","'use strict';\n\nvar bindInternal4 = require('../function/bindInternal4');\n\n/**\n * # Reduce\n *\n * A fast object `.reduce()` implementation.\n *\n * @param  {Object}   subject      The object to reduce over.\n * @param  {Function} fn           The reducer function.\n * @param  {mixed}    initialValue The initial value for the reducer, defaults to subject[0].\n * @param  {Object}   thisContext  The context for the reducer.\n * @return {mixed}                 The final result.\n */\nmodule.exports = function fastReduceObject (subject, fn, initialValue, thisContext) {\n  var keys = Object.keys(subject),\n      length = keys.length,\n      iterator = thisContext !== undefined ? bindInternal4(fn, thisContext) : fn,\n      i, key, result;\n\n  if (initialValue === undefined) {\n    i = 1;\n    result = subject[keys[0]];\n  }\n  else {\n    i = 0;\n    result = initialValue;\n  }\n\n  for (; i < length; i++) {\n    key = keys[i];\n    result = iterator(result, subject[key], key, subject);\n  }\n\n  return result;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/fast.js/object/reduce.js\n ** module id = 23\n ** module chunks = 0\n **/","var type = require('component-type')\n\n/**\n * Returns the type of a virtual node\n *\n * @param  {Object} node\n * @return {String}\n */\n\nmodule.exports = function nodeType (node) {\n  var v = type(node)\n  if (v === 'null' || node === false) return 'empty'\n  if (v !== 'object') return 'text'\n  if (type(node.type) === 'string') return 'element'\n  return 'component'\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/deku/lib/node-type.js\n ** module id = 24\n ** module chunks = 0\n **/","/**\n * toString ref.\n */\n\nvar toString = Object.prototype.toString;\n\n/**\n * Return the type of `val`.\n *\n * @param {Mixed} val\n * @return {String}\n * @api public\n */\n\nmodule.exports = function(val){\n  switch (toString.call(val)) {\n    case '[object Date]': return 'date';\n    case '[object RegExp]': return 'regexp';\n    case '[object Arguments]': return 'arguments';\n    case '[object Array]': return 'array';\n    case '[object Error]': return 'error';\n  }\n\n  if (val === null) return 'null';\n  if (val === undefined) return 'undefined';\n  if (val !== val) return 'nan';\n  if (val && val.nodeType === 1) return 'element';\n\n  if (typeof Buffer != 'undefined' && Buffer.isBuffer(val)) return 'buffer';\n\n  val = val.valueOf\n    ? val.valueOf()\n    : Object.prototype.valueOf.apply(val)\n\n  return typeof val;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/component-type/index.js\n ** module id = 25\n ** module chunks = 0\n **/","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192 // not used by this implementation\n\nvar rootParent = {}\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property\n *     on objects.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\nfunction typedArraySupport () {\n  function Bar () {}\n  try {\n    var arr = new Uint8Array(1)\n    arr.foo = function () { return 42 }\n    arr.constructor = Bar\n    return arr.foo() === 42 && // typed array instances can be augmented\n        arr.constructor === Bar && // constructor can be set\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (arg) {\n  if (!(this instanceof Buffer)) {\n    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n    return new Buffer(arg)\n  }\n\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    this.length = 0\n    this.parent = undefined\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    return fromNumber(this, arg)\n  }\n\n  // Slightly less common case.\n  if (typeof arg === 'string') {\n    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n  }\n\n  // Unusual.\n  return fromObject(this, arg)\n}\n\nfunction fromNumber (that, length) {\n  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < length; i++) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\n  // Assumption: byteLength() return value is always < kMaxLength.\n  var length = byteLength(string, encoding) | 0\n  that = allocate(that, length)\n\n  that.write(string, encoding)\n  return that\n}\n\nfunction fromObject (that, object) {\n  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\n  if (isArray(object)) return fromArray(that, object)\n\n  if (object == null) {\n    throw new TypeError('must start with number, buffer, array or string')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined') {\n    if (object.buffer instanceof ArrayBuffer) {\n      return fromTypedArray(that, object)\n    }\n    if (object instanceof ArrayBuffer) {\n      return fromArrayBuffer(that, object)\n    }\n  }\n\n  if (object.length) return fromArrayLike(that, object)\n\n  return fromJsonObject(that, object)\n}\n\nfunction fromBuffer (that, buffer) {\n  var length = checked(buffer.length) | 0\n  that = allocate(that, length)\n  buffer.copy(that, 0, 0, length)\n  return that\n}\n\nfunction fromArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Duplicate of fromArray() to keep fromArray() monomorphic.\nfunction fromTypedArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  // Truncating the elements is probably not what people expect from typed\n  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n  // of the old Buffer constructor.\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    array.byteLength\n    that = Buffer._augment(new Uint8Array(array))\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromTypedArray(that, new Uint8Array(array))\n  }\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n// Returns a zero-length buffer for inputs that don't conform to the spec.\nfunction fromJsonObject (that, object) {\n  var array\n  var length = 0\n\n  if (object.type === 'Buffer' && isArray(object.data)) {\n    array = object.data\n    length = checked(array.length) | 0\n  }\n  that = allocate(that, length)\n\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n} else {\n  // pre-set for values that may exist in the future\n  Buffer.prototype.length = undefined\n  Buffer.prototype.parent = undefined\n}\n\nfunction allocate (that, length) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = Buffer._augment(new Uint8Array(length))\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that.length = length\n    that._isBuffer = true\n  }\n\n  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n  if (fromPool) that.parent = rootParent\n\n  return that\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (subject, encoding) {\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\n  var buf = new Buffer(subject, encoding)\n  delete buf.parent\n  return buf\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  var i = 0\n  var len = Math.min(x, y)\n  while (i < len) {\n    if (a[i] !== b[i]) break\n\n    ++i\n  }\n\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; i++) {\n      length += list[i].length\n    }\n  }\n\n  var buf = new Buffer(length)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nfunction byteLength (string, encoding) {\n  if (typeof string !== 'string') string = '' + string\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'binary':\n      // Deprecated\n      case 'raw':\n      case 'raws':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  start = start | 0\n  end = end === undefined || end === Infinity ? this.length : end | 0\n\n  if (!encoding) encoding = 'utf8'\n  if (start < 0) start = 0\n  if (end > this.length) end = this.length\n  if (end <= start) return ''\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'binary':\n        return binarySlice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return 0\n  return Buffer.compare(this, b)\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n  byteOffset >>= 0\n\n  if (this.length === 0) return -1\n  if (byteOffset >= this.length) return -1\n\n  // Negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\n  if (typeof val === 'string') {\n    if (val.length === 0) return -1 // special case: looking for empty string always fails\n    return String.prototype.indexOf.call(this, val, byteOffset)\n  }\n  if (Buffer.isBuffer(val)) {\n    return arrayIndexOf(this, val, byteOffset)\n  }\n  if (typeof val === 'number') {\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n    }\n    return arrayIndexOf(this, [ val ], byteOffset)\n  }\n\n  function arrayIndexOf (arr, val, byteOffset) {\n    var foundIndex = -1\n    for (var i = 0; byteOffset + i < arr.length; i++) {\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n      } else {\n        foundIndex = -1\n      }\n    }\n    return -1\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\n// `get` is deprecated\nBuffer.prototype.get = function get (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` is deprecated\nBuffer.prototype.set = function set (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) throw new Error('Invalid hex string')\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    var swap = encoding\n    encoding = offset\n    offset = length | 0\n    length = swap\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'binary':\n        return binaryWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  if (newBuf.length) newBuf.parent = this.parent || this\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n  if (offset < 0) throw new RangeError('index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; i--) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    target._set(this.subarray(start, start + len), targetStart)\n  }\n\n  return len\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (end < start) throw new RangeError('end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1) {\n        buf[i] = this[i]\n      }\n      return buf.buffer\n    }\n  } else {\n    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function _augment (arr) {\n  arr.constructor = Buffer\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array set method before overwriting\n  arr._set = arr.set\n\n  // deprecated\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.equals = BP.equals\n  arr.compare = BP.compare\n  arr.indexOf = BP.indexOf\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUIntLE = BP.readUIntLE\n  arr.readUIntBE = BP.readUIntBE\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readIntLE = BP.readIntLE\n  arr.readIntBE = BP.readIntBE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUIntLE = BP.writeUIntLE\n  arr.writeUIntBE = BP.writeUIntBE\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeIntLE = BP.writeIntLE\n  arr.writeIntBE = BP.writeIntBE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; i++) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/buffer/index.js\n ** module id = 26\n ** module chunks = 0\n **/","var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n\t'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n\tvar PLUS   = '+'.charCodeAt(0)\n\tvar SLASH  = '/'.charCodeAt(0)\n\tvar NUMBER = '0'.charCodeAt(0)\n\tvar LOWER  = 'a'.charCodeAt(0)\n\tvar UPPER  = 'A'.charCodeAt(0)\n\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n\tfunction decode (elt) {\n\t\tvar code = elt.charCodeAt(0)\n\t\tif (code === PLUS ||\n\t\t    code === PLUS_URL_SAFE)\n\t\t\treturn 62 // '+'\n\t\tif (code === SLASH ||\n\t\t    code === SLASH_URL_SAFE)\n\t\t\treturn 63 // '/'\n\t\tif (code < NUMBER)\n\t\t\treturn -1 //no match\n\t\tif (code < NUMBER + 10)\n\t\t\treturn code - NUMBER + 26 + 26\n\t\tif (code < UPPER + 26)\n\t\t\treturn code - UPPER\n\t\tif (code < LOWER + 26)\n\t\t\treturn code - LOWER + 26\n\t}\n\n\tfunction b64ToByteArray (b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr\n\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tvar len = b64.length\n\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\n\t\tvar L = 0\n\n\t\tfunction push (v) {\n\t\t\tarr[L++] = v\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\tpush(tmp & 0xFF)\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\treturn arr\n\t}\n\n\tfunction uint8ToBase64 (uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length\n\n\t\tfunction encode (num) {\n\t\t\treturn lookup.charAt(num)\n\t\t}\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t}\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\toutput += tripletToBase64(temp)\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\toutput += '=='\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\toutput += '='\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn output\n\t}\n\n\texports.toByteArray = b64ToByteArray\n\texports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/base64-js/lib/b64.js\n ** module id = 27\n ** module chunks = 0\n **/","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/ieee754/index.js\n ** module id = 28\n ** module chunks = 0\n **/","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/isarray/index.js\n ** module id = 29\n ** module chunks = 0\n **/","var defaults = require('object-defaults')\nvar nodeType = require('./node-type')\nvar type = require('component-type')\n\n/**\n * Expose `stringify`.\n */\n\nmodule.exports = function (app) {\n  if (!app.element) {\n    throw new Error('No element mounted')\n  }\n\n  /**\n   * Render to string.\n   *\n   * @param {Component} component\n   * @param {Object} [props]\n   * @return {String}\n   */\n\n  function stringify (component, optProps, children) {\n    var propTypes = component.propTypes || {}\n    var props = defaults(optProps || {}, component.defaultProps || {})\n    var state = component.initialState ? component.initialState(props) : {}\n    props.children = children;\n\n    for (var name in propTypes) {\n      var options = propTypes[name]\n      if (options.source) {\n        props[name] = app.sources[options.source]\n      }\n    }\n\n    if (component.beforeMount) component.beforeMount({ props: props, state: state })\n    if (component.beforeRender) component.beforeRender({ props: props, state: state })\n    var node = component.render({ props: props, state: state })\n    return stringifyNode(node, '0')\n  }\n\n  /**\n   * Render a node to a string\n   *\n   * @param {Node} node\n   * @param {Tree} tree\n   *\n   * @return {String}\n   */\n\n  function stringifyNode (node, path) {\n    switch (nodeType(node)) {\n      case 'empty': return '<noscript />'\n      case 'text': return node\n      case 'element':\n        var children = node.children\n        var attributes = node.attributes\n        var tagName = node.type\n        var innerHTML = attributes.innerHTML\n        var str = '<' + tagName + attrs(attributes) + '>'\n\n        if (innerHTML) {\n          str += innerHTML\n        } else {\n          for (var i = 0, n = children.length; i < n; i++) {\n            str += stringifyNode(children[i], path + '.' + i)\n          }\n        }\n\n        str += '</' + tagName + '>'\n        return str\n      case 'component': return stringify(node.type, node.attributes, node.children)\n    }\n\n    throw new Error('Invalid type')\n  }\n\n  return stringifyNode(app.element, '0')\n}\n\n/**\n * HTML attributes to string.\n *\n * @param {Object} attributes\n * @return {String}\n * @api private\n */\n\nfunction attrs (attributes) {\n  var str = ''\n  for (var key in attributes) {\n    var value = attributes[key]\n    if (key === 'innerHTML') continue\n    if (isValidAttributeValue(value)) str += attr(key, attributes[key])\n  }\n  return str\n}\n\n/**\n * HTML attribute to string.\n *\n * @param {String} key\n * @param {String} val\n * @return {String}\n * @api private\n */\n\nfunction attr (key, val) {\n  return ' ' + key + '=\"' + val + '\"'\n}\n\n/**\n * Is a value able to be set a an attribute value?\n *\n * @param {Any} value\n *\n * @return {Boolean}\n */\n\nfunction isValidAttributeValue (value) {\n  var valueType = type(value)\n  switch (valueType) {\n  case 'string':\n  case 'number':\n    return true;\n\n  case 'boolean':\n    return value;\n\n  default:\n    return false;\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/deku/lib/stringify.js\n ** module id = 30\n ** module chunks = 0\n **/","/**\n * Module dependencies.\n */\n\nvar slice = require('sliced')\nvar flatten = require('array-flatten')\n\n/**\n * This function lets us create virtual nodes using a simple\n * syntax. It is compatible with JSX transforms so you can use\n * JSX to write nodes that will compile to this function.\n *\n * let node = element('div', { id: 'foo' }, [\n *   element('a', { href: 'http://google.com' }, 'Google')\n * ])\n *\n * You can leave out the attributes or the children if either\n * of them aren't needed and it will figure out what you're\n * trying to do.\n */\n\nmodule.exports = element\n\n/**\n * Create virtual trees of components.\n *\n * This creates the nicer API for the user.\n * It translates that friendly API into an actual tree of nodes.\n *\n * @param {*} type\n * @param {Object} attributes\n * @param {Array} children\n * @return {Object}\n * @api public\n */\n\nfunction element (type, attributes, children) {\n  // Default to div with no args\n  if (!type) {\n    throw new TypeError('element() needs a type.')\n  }\n\n  // Skipped adding attributes and we're passing\n  // in children instead.\n  if (arguments.length === 2 && (typeof attributes === 'string' || Array.isArray(attributes))) {\n    children = [ attributes ]\n    attributes = {}\n  }\n\n  // Account for JSX putting the children as multiple arguments.\n  // This is essentially just the ES6 rest param\n  if (arguments.length > 2) {\n    children = slice(arguments, 2)\n  }\n\n  children = children || []\n  attributes = attributes || {}\n\n  // Flatten nested child arrays. This is how JSX compiles some nodes.\n  children = flatten(children, 2)\n\n  // Filter out any `undefined` elements\n  children = children.filter(function (i) { return typeof i !== 'undefined' })\n\n  // if you pass in a function, it's a `Component` constructor.\n  // otherwise it's an element.\n  return {\n    type: type,\n    children: children,\n    attributes: attributes\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/virtual-element/index.js\n ** module id = 31\n ** module chunks = 0\n **/","module.exports = exports = require('./lib/sliced');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/sliced/index.js\n ** module id = 32\n ** module chunks = 0\n **/","\n/**\n * An Array.prototype.slice.call(arguments) alternative\n *\n * @param {Object} args something with a length\n * @param {Number} slice\n * @param {Number} sliceEnd\n * @api public\n */\n\nmodule.exports = function (args, slice, sliceEnd) {\n  var ret = [];\n  var len = args.length;\n\n  if (0 === len) return ret;\n\n  var start = slice < 0\n    ? Math.max(0, slice + len)\n    : slice || 0;\n\n  if (sliceEnd !== undefined) {\n    len = sliceEnd < 0\n      ? sliceEnd + len\n      : sliceEnd\n  }\n\n  while (len-- > start) {\n    ret[len - start] = args[len];\n  }\n\n  return ret;\n}\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/sliced/lib/sliced.js\n ** module id = 33\n ** module chunks = 0\n **/","'use strict'\n\n/**\n * Expose `arrayFlatten`.\n */\nmodule.exports = arrayFlatten\n\n/**\n * Recursive flatten function with depth.\n *\n * @param  {Array}  array\n * @param  {Array}  result\n * @param  {Number} depth\n * @return {Array}\n */\nfunction flattenWithDepth (array, result, depth) {\n  for (var i = 0; i < array.length; i++) {\n    var value = array[i]\n\n    if (depth > 0 && Array.isArray(value)) {\n      flattenWithDepth(value, result, depth - 1)\n    } else {\n      result.push(value)\n    }\n  }\n\n  return result\n}\n\n/**\n * Recursive flatten function. Omitting depth is slightly faster.\n *\n * @param  {Array} array\n * @param  {Array} result\n * @return {Array}\n */\nfunction flattenForever (array, result) {\n  for (var i = 0; i < array.length; i++) {\n    var value = array[i]\n\n    if (Array.isArray(value)) {\n      flattenForever(value, result)\n    } else {\n      result.push(value)\n    }\n  }\n\n  return result\n}\n\n/**\n * Flatten an array, with the ability to define a depth.\n *\n * @param  {Array}  array\n * @param  {Number} depth\n * @return {Array}\n */\nfunction arrayFlatten (array, depth) {\n  if (depth == null) {\n    return flattenForever(array, [])\n  }\n\n  return flattenWithDepth(array, [], depth)\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/array-flatten/array-flatten.js\n ** module id = 34\n ** module chunks = 0\n **/","'use strict';\n\nvar SearchItemInArray = function SearchItemInArray(items, input) {\n  if (input.trim() === '') {\n    return [];\n  }\n  var reg = new RegExp(input.split('').join('\\\\w*').replace(/\\W/, ''), 'i');\n\n  return items.filter(function (item) {\n    if (reg.test(item)) {\n      return item;\n    }\n  });\n};\n\nmodule.exports = SearchItemInArray;\n\n\n/** WEBPACK FOOTER **\n ** ../lib/SearchItemInArray.js\n **/","/** @jsx element */\n\nimport {render,tree} from 'deku'\nimport element from 'virtual-element'\n\nlet Counter = {\n\n  initialState () {\n    return { secondsElapsed: 0 }\n  },\n\n  render (component) {\n    let { props, state } = component;\n    let { secondsElapsed } = state;\n\n    return (\n      <div class='counter'>\n        <h1 class={`counter--${props.color}`}>\n          Counter: { secondsElapsed }\n        </h1>\n      </div>\n    );\n  },\n\n  afterUpdate (component) {\n    let { props, state } = component;\n  },\n\n  afterMount (component, el, setState) {\n    var counter = 0;\n    component.interval = setInterval(() => {\n       setState({ secondsElapsed: counter++ })\n    }, 1000);\n  },\n\n  beforeUnmount (component) {\n    clearInterval(component.interval);\n  }\n}\n\nexport default Counter\n\n\n/** WEBPACK FOOTER **\n ** ./Counter.js\n **/"],"sourceRoot":""}